<!DOCTYPE html>
<html>
	<head>
		<title>博客主页</title>
	</head>
	<body>
  <h1>github</h1>
  <h2>github</h2>
  <h3>github</h3>
  <h4>github</h4>
  <h5>1、property与attribute的区别
答：Property属于面向对象的范畴。比如一个物体的长、宽、高、名称、速度（）、能办的事情（）等
	Attribute则是编程语言文法层面的东西。比如两个同类的语法元素A和B，为了表示A与B的不完全相同或者A与B在用法上有些区别，这时候就要针对A和B加一些Attribute。也就是说Attribute只与语言层面上的东西相关，与抽象出来的对象没什么关系。意在“区分”，故有称之为特性。
	XAML中Property与Attribute可能会重叠。

2、
<Window x:Class="WpfApplication1.Window16"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Window16" Height="300" Width="300">	
	<Grid>
	</Grid>
	</Window>

其中xmlns特征用来定义名称空间（Namespace），xmlns也就是XML-Namespace的缩写。定义名称空间的好处就是，当来源不同的类重名时，可以使用名称空间加以区分。
	语法格式：
			xmlns[:可选的映射前缀]=”名称空间”
xmlns后可以跟一个可选的映射前缀，之间用冒号分隔。如果没有写可选映射前缀，那就意味着所有来自于这个名称空间的标签都不用加前缀，这个没有映射前缀的名称空间称为“默认名称空间”——默认名称空间只能有一个，而且应该选择其中元素被最频繁使用的名称空间来充当默认名称空间。上面的代码中，Class特性来自于第三行中x:前缀对应的名称空间。<Window>、<Grid>都来自第二行声明的默认名称空间。
	如果给第二行声明的名称空间加上一个前缀，比如n，那么代码就必须改成这样才能通过编译：
<n:Window x:Class="WpfApplication1.Window16"（将XAML解析成C#类）
        xmlns:n="http://schemas.microsoft.com/winfx/2006/xaml/presentation"（绘制UI相关程序集）
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"（语言解析处理）
        Title="Window16" Height="300" Width="300">	
	< n:Grid>
	</ n:Grid>
	</ n:Window>

另外，其中跟网址一样的代码其实是XAML解析器的一个硬性编码（hard-coding），只要见到这些固定的字符串，就会把一系列必要的程序集（Assembly）和程序集中包含的.Net名称空间引用进来。

XAML使用树形逻辑结构来描述UI。（工具：VisualTreeHelper和LogicalTreeHelper）
XAML是一种声明性语言，XAML编译器会为每个标签创建一个与之对应的对象。对象不能运行逻辑，但是对其属性进行必要的初始化（赋值）才会有意义。（1、使用字符串进行简单赋值   2、使用树形元素（Property Element进行复杂赋值）。
但当通过Attribute=Value语法赋值时，由于XAML的语法限制，Value只能是一个字符串值。这就引出了两个问题：
问题：
1、	如果一个类能使用XAML语言进行声明，并允许它的Property与XAML的Attribute互相映射，那就需要为这些Property准备适当的转换机制
2、	由于Value是个字符串，所以其格式复杂程度有限，尽管可以在转换机制里包含一定的按格式解析字符串的功能以便转换成较复杂的目标对象，但这回让最终的XAML使用者头疼不已。因为他们不得不在没有编码辅助的情况下手写一个格式复杂的字符串以满足赋值要求。
解决：
1、	第一个问题的解决方案是使用TypeConverter类的派生类，在派生类里重写TypeConvert的一些方法。
2、	第二个问题的解决办法就是使用属性元素（Property Element）
【TypeConverter 类】官方文档
https://msdn.microsoft.com/zh-cn/library/system.componentmodel.typeconverter.aspx

简化XAML的技巧：
	能使用Attribute=Value形式赋值的，就不使用属性元素
	充分利用默认值，取出冗余
	充分利用XAML的简写方式
<n:TextBox Height="23" HorizontalAlignment="Left" Margin="141,46,0,0" Name="textBox1" VerticalAlignment="Top" Width="120"  Text="{Binding Path=Value,ElementName=slider1,Mode=TwoWay,UpdateSourceTrigger=LostFocus}"/>

所谓标记扩展，实际上是一种特殊的Attribute=Value语法，其特殊的地方在于Value字符串是由一对花括号括起来的内容组成，XANL编译器会对这样的内容作出解析，生成相应的对象。
Text="{Binding Path=Value,ElementName=slider1,Mode=TwoWay,UpdateSourceTrigger=LostFocus}"

当编译器看到这句代码时就会把花括号里的内容解析成相应的对象
对象的数据类型名是紧邻左花括号的字符串
对象的属性由一串以逗号连接的子字符串负责初始化（注意，属性值不再加引号）

并不是所有对象都能用标记扩展的语法来书写，只有MarkU盘Ex疼死哦了类的派生类（直接或间接）才能使用标记扩展语法来创建对象。

一个有意思的标签——x:Code，使用它可以把本来应该呆在后置代码里的C#代码搬到XAML文件中来。x:Code内容一定要使用XML语言的<![CDATA[…]]>转义标签
<x:Code>
        <![CDATA[
            private void MainWindow_Load(参数，参数)
            {
                //处理逻辑
            }
        ]]>
   </x:Code>

引用命名空间格式：
	xmlns:映射名= "clr-namespace:类库中名称空间的名字;assembly=类库文件名"

WPF绘制图形过程
	PS/AI→Expression Blend→WPF

第四章	命名空间详解
名称	种类（在XAML中出现的形式）
x:Array	标签扩展
x:Class	Attribute
x:ClassModifier	Attribute
x:Code	XAML指令元素
x:FieldModifier	Attribute
x:Key	Attribute
x:Name	Attribute
x:Null	标签扩展
x:Shared	Attribute
x:Static	标签扩展
x:Subclass	Attribute
x:Type	标签扩展
x:TypeArguments	Attribute
x:Uid	Attribute
x:Xdata	XAML指令元素
Attribute
x:Class
	这个Attribute的作用是告诉XAML编译器将XAML标签的编译结果与后台代码中指定的类合并。在使用x:Class时必须遵循以下要求：
	这个Attribute只能用于根节点
使用x:Class的根节点的类型要与x:Class的值说指示的类型保持一致
x:Class的值所指示的类型要与x:Class的值所指示的类型保持一致
x:Class已经在剖析最简单的WPF程序时讲过，温故而知新

x:ClassModifier
	这个Attribute的作用是告诉XAML编译由便签编译生成的类具有怎么的访问控制级别。
使用这个Attribute时需要注意：
	便签必须具有x:Class Attribute。
	x:ClassModifier的值必须与x:Class 所指示类的访问控制级别一致
x:ClassModifier的值随后台代码的编译语言不同而有所不同，参见Type:Attribute枚举类型

x:Name
	为这个标签（对象）声明引用变量 ，以便后台代码调用。
	作用：
1、	告诉XAML编译器，当一个标签带有x:Name时除了为这个便签生成对应实例外还要为这个实例声明一个引用变量，变量名就是x:Name的值
2、	将XAML便签所对应对象的Name属性（如果有）也设为x:Name的值，并把这个值注册到UI树上，以方便查找。
当一个元素具有Name属性时，使用Name或x:Name效果是一样的。如果元素没有Name属性，那就必须用x:Name。


x:FieldModifier
	是用来在XAML里改变引用变量访问级别的。（使用x:FieldModifier的前提是这个元素使用了x:Name）
<TextBlock x:Name="niin" x:FieldModifier="public"></TextBlock>

x:Key
	最自然的检索方式莫过于使用”Key-Value”对的形式了。
	x:Key的作用就是为资源贴上用于检索的索引。在WPF中，机会每个元素都有自己的Resources属性，这个属性是个”Key-Value”式的集合，只要把元素放进这个集合，这个元素就称为资源字典中的一个条目。
	资源不但在XAML中可以访问，在C#中也可以。var   v=this.FindResources(“资源名”) ;

x:Shared
	它决定了我们通过检索得到的资源是资源本身还是资源的副本（资源被多次引用时），需与x:Key配合使用
	true : 每次检索到这个对象时，得到的都是同一个对象
	false: 每次检索到这个对象时，得到的都是这个对象的副本


标签扩展
x:Type
	x:Type的值应该是一个数据类型的名称。
<local:MyButton Content="Show" UserWindowType="{x:Type TypeName=local:MyWindow}" Margin="5"/>

	看示例

x:Null
	有时候我们需要显示地对一个属性赋一个空值。
	如果一个属性具有默认值而我们又不需要这个默认值时就需要显示地设置为null值了。

x:Array
	x:Array的作用就是通过它的Items属性向使用者暴露一个已知的ArrayList实例，ArrayList内成员的类型由x:Array
的Type指明。

x:Static
	x:Static是一个很常用的标记扩展，它的功能是在XAML文档中使用数据类型的static成员。

指令元素
x:Code
	x:Code的作用是可以包含一些本应该放置在后置代码中的C#代码，这样做的好处是不用把XAML代码和C#代码分置在两个文件中，但若不是遇到极端环境我想应该没人这么干，特例。

x:Xdata
	x:Xdata是一个专用标签。WPF中把包含数据的对象称为数据源，用于把数据源中的数据提供给数据使用者的对象被称为数据提供者（Data Provider）。WPF类库中包含多种数据提供者，其中有一个类叫XmlDataProvider，专门用于提供XML化的数据。如果想在XAML里声明一个带有数据的XmlDataProvider实例，那么XmlDataProvider实例的数据就要放在x:Xdata标签的内容里。

第五章  控件与布局
	从现在开始，你就要在心中树立起这样一个概念——WPF中是数据驱动UI，数据是核心，是主动的；UI从属于数据并表达数据、是被动的。
	ContentControl族
		均派生自ContentControl类
		它们都是控件
		内容属性的名称为Content
		只能由单一元素充当其内容
	HearderredContentControl族
		均派生自HearderredContentControl,儿HearderredContentControl派生自ContentControl类
		它们都是控件，用于显示带标题的数据
		除了用于显示主体内容的区域外，控件还具有一个显示标题（Hearder）的区域
		内容属性为Content和Hearder
		无论是Content还是Hearder都只能容纳一个元素充当其内容
	ItemsControl族
		均派生自ItemsControl类
		他们都是控件，用于 列表化的数据
		内容属性为Items或ItemsSource
		每种ItemsControl都对应有自己的条目容器
		（无论将什么样类型的数据集交给ItemsControl控件，他都会自动进行包装进条目容器，生成自己相对应的条目）
		辅助类：VisualTreeHelper
		快捷设置：DisplayMemberPath
				  SelectValuePath
	HearderredItemsControl族
		除了具有ItemsControl族的功能外，还具有标题的能力
	Decorator族
本族中的元素是在UI上装饰效果的。如可以使用Border元素为一些组织在一起的内容加个边框。如果需要组织在一起的内容能够自由缩放，则可使用ViewBox元素。
		均派生自Decorator类
		起UI装饰作用
		内容属性为Child
		只能由单一元素充当内容
	TextBlock和TextBox
		TextBox：不需要太多的格式显示，所以它的内容是简单的字符串，内容属性为Text
		TextBlock：由于需要操作格式，所以内容属性是Inlines（印刷中的“行”），同时，TextBlock也是一个名为Text的属性，
				  当简单地显示一个字符串时，可以使用这个属性。
	Shape族元素
		简单的视觉元素，不是控件。
		专门用来在UI上绘制图形的一类元素，这类元素没有自己的内容，我们可以使用Fill属性为它们设置填充效果，还可以
使用Stroke属性为它们设置边线的效果。
	均派生自Shape类
用于2D图形绘制
	无内容属性
	使用Fill属性设置填充，使用Stroke属性设置边线

Panel族元素
	太重要——所有用于UI布局的元素都属于它的范围。
	均派生自Panel抽象类
	主要功能是控制UI布局
	内容属性为Children
	内容可以是多个元素，Panel元素将控制它们的布局。

Content包含


Grid：网格	可以自定义行和列并通过行列的数量、行高和列宽来调整空间的布局。近似于HTML中的Table
StackPanel：栈式面板	可将包含的元素在竖直或水平方向上排成一条直线，当移除一个元素后，后面的元素会自动向前移动以填充空缺
Canvas：画布	内部元素可以使用以像素为单位的绝对坐标进行定位，类似于Windows Form编程的布局方式
DockPanel：泊靠式面板	内部元素可以选择泊靠方向，类似于在Windows Form编程中设置控件的Dock属性
WrapPanel：自动拆行面板	内部元素在排满一行后能够自动拆行，类似于HTML中的流式布局


第六章  深入浅出话Binding
	Windows GUI运行的机理是使用消息（Message）来驱使程序向前运行。
	程序的本质：数据+算法
class Student:INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;
        /// <summary>
        /// 被传递给UI以显示的属性我们称之为Binding的路径（Path）
        /// 当为Binding设置数据源后，Binding就会自动侦听来自这个接口的PropertyChanged事件。
        /// </summary>
        private String name;
        public String Name
        {
            get { return name; }
            set 
            { 
                name = value; 
                //激发事件
                if (this.PropertyChanged != null)
                {
                    this.PropertyChanged.Invoke(this,new PropertyChangedEventArgs("Name"));
                }
            }
        }
   }

	
 
 

	Binding的源和路径
Binding的源也就是数据的源头。Binding对源的要求并不苛刻——只要他是一个对象，并且通过属性（Property）公开自己的数据，他就能作为Binding的源。
		要让作为Binding源的对象具有自动通知Binding自己的属性值已经变化的能力，那么就需要让类实InotifyPropertyChanged
	接口并在属性的set语句中激发PropertyChanged事件。
6.3.1把控件作为Binding源与Binding标记扩展	<TextBox x:Name="tbox" Text="{Binding Path=Value, ElementName=slider}" ></TextBox>
与之等价的C#代码是：
this.tbox.SetBinding(TextBox.TextProperty, new Binding("Value") {ElementName="slider" });

♣ 因为在C#代码中我们可以直接访问空间对象，所以一般也不会使用Binding的ElementName属性，而
是直接把对象赋值给Binding的Source属性。
♣ Text属性设置Binding为……
6.3.2控制Binding的方向及数据更新	♣ Binding在源与目标之间架起了沟通的桥梁，默认情况下数据既能够通过Binding送达目标，也能够从目标返回源（收集用户对数据的修改）

♣ 控制Binding数据流向的属性是Model，它是类型是BindingModel枚举。BindingModel可取值为TwoWay、OneWay、OnTime、OneWayToSource和Default。（Default是指Binding模式会根据实际情况来调整，比如可编辑的采用双向模式，只读的采用单项模式）

♣ UpdateSourceTrigger——它的类型是UpdateSourceTrigger枚举，可取值为PropertyChanged、LostFocus、Explicit、和Default。源更新触发器触发模式。
♣ 另外：Binding还具有NotifyOnSourceUpdated和NotifyOnTargetUpdated两个bool类型的属性。如果设为true，则当源或目标被更新后Binding会激发相应的SourceUpdated事件和TargetUpdated事件。实际工作中，我们可以通过监听这两个事件找出有哪些数据或控件被更新了
6.3.3 Binding的路径（Path）	♣ Path属性来指定Binding需要关注的源的某个属性
♣ Path的实际类型是PropertyPath
<TextBox x:Name="tbox" Text="{Binding Path=Value, ElementName=slider}" ></TextBox>
等效的C#代码是：

Binding binding=new Binding(){Path=new PropertyPath("Value"),Source=this.slider};
This.textBox1.SetBinding(TextBox.TextProperty,binding);
或使用Binding的构造器简写为：
Binding binding=new Binding("Value"){Source=this.slider};
This.textBox1.SetBinding(TextBox.TextProperty,binding);

♣  Binding还支持多级路径（通俗滴讲就是一路“点”下去）
<TextBox x:Name="textBox1" Margin="5">ABDGHKHDJDHRBAIIWENGS</TextBox>
<TextBox x:Name="textBox2" Margin="5" Text="{Binding Path=Text.Length,ElementName=textBox1,Mode=OneWay}"></TextBox>
与之等价的C#代码是：
this.textBox2.SetBinding(TextBox.TextProperty, new Binding("Text.legth") { Source = this.textBox1 ,Mode=BindingMode.OneWay});

<TextBox x:Name="textBox3" Margin="5" Text="{Binding Path=Text.[6],ElementName=textBox1, Mode=OneWay}"></TextBox>
显示文本中相应索引的字符，我们甚至可以将Text.[6]中的 . 取掉，照样可以正常运行
this.textBox2.SetBinding(TextBox.TextProperty, new Binding("Text.[6]") { Source = this.textBox1 ,Mode=BindingMode.OneWay});


♣ 当使用一个集合或者DataView作为Binding源时，如果我们想把它的默认元素当做Path使用，则需要：
List<String> stringList = new List<string>() { "Tim","Tom","Jeck"};
this.tetxBox4.SetBinding(TextBox.TextProperty,new Binding("/"){Source=stringList});
this.tetxBox5.SetBinding(TextBox.TextProperty,new Binding("/Length"){Source=stringList ,Mode=BindingMode.OneWay});
this.tetxBox6.SetBinding(TextBox.TextProperty, new Binding("/[2]") { Source = stringList, Mode = BindingMode.OneWay });
♣ 如果集合元素的属性仍然还是一个集合，我们想把子级集合中的元素当做Path，则可以使用多级斜线的语法（即一路“斜线下去”）：
List<City> cityList = new List<City> { /*初始化....*/};
cityList.Add(new City() { Name="济南" });
cityList.Add(new City() { Name = "长沙" });
cityList.Add(new City() { Name = "福州" });
cityList.Add(new City() { Name = "苏州" });
cityList.Add(new City() { Name = "广州" });
List<Province> provinceList = new List<Province>();
provinceList.Add(new Province(){Name="华东"});
provinceList[0].CityList = cityList;
List<Country> countryList = new List<Country>();
countryList.Add(new Country() { Name = "中华" });
countryList[0].ProvinceList = provinceList;

this.tetxBox7.SetBinding(TextBox.TextProperty, new Binding("/Name") { Source = countryList });
this.tetxBox8.SetBinding(TextBox.TextProperty, new Binding("/ProvinceList[0].Name") { Source = countryList });
this.tetxBox9.SetBinding(TextBox.TextProperty, new Binding("/ProvinceList/CityList[1].Name") { Source = countryList });

6.3.4“没有Path”的Binding	♣有些时候我们会在代码中看到一些Path是一个“.“或者干脆没有Path的Binding。——Binding源本身就是数据且不需要Path来指明。
int k = 100000;
this.tetxBox10.SetBinding(TextBox.TextProperty, new Binding(".") { Source = k ,Mode=BindingMode.TwoWay});

<StackPanel>
    <StackPanel.Resources>
          <sys:String x:Key="myString">
               菩提本无树，明镜亦非台 
               本来无一物，何处惹尘埃
          </sys:String>
     </StackPanel.Resources>       
     <TextBlock x:Name="textBlock" Margin="5" Text="{Binding Path=., Source={StaticResource ResourceKey=myString}}"></TextBlock>
</StackPanel>
绑定那句可简写成： Text="{Binding ., Source={StaticResource ResourceKey=myString}}"
或： Text="{Binding  Source={StaticResource ResourceKey=myString}}"

♣ PropertyPath类型除了用于Binding的Path属性外，在动画编程的时候也会排上用场（Storyboard.TargetProperty），在用于动画编程时，PropertyPath还有另外的语法。


6.3.5 为Binding指定源（Source）的几种方法	Binding的源是数据的来源，所以只要一个对象包含数据并能通过属性把数据暴露出来，它就能当做Binding的源来使用。
♣  把普通CLR类型单个对象指定为Source：包括NET Framework 自带类型的对象和用户自定义的对
象。如果类型对象实现InotifyPropertyChanged接口，则可通过在属性的set语句激发PropertyChanged事件来通知Binding数据已被更新
♣  把普通CLR集合类型对象指定为Source：一般是把控件的ItemsSource属性使用Binding关联到一个集合对象上。
  
 
6.3.6 没有Source的Binding——使用DataContext作为Binding源	前面的例子都是把单个CLR类型对象指定为Binding的Source，方法有两种——把对象赋值给Binding.Source属性 或 把对象的Name赋值给Binding..ElementName。
 
♣  当你没有为控件的某个依赖属性显示赋值的时候，控件会把自己容器的属性值“借过来”当做自己的属性值。
这就是为什么Path和Source在某些情况下不需要显示的放在代码里的原因。（实际上属性沿着UI元素向下传递了。）
♣  在实际工作中DataContext的用法非常灵活：
（1）	当UI上的多个控件都使用Binding关注同一个对象时，不妨使用DataContext
（2）	当作为Source的对象不能被直接访问的时候——比如B窗体内的控件想把A窗体内的控件当做自己的Binding源时，但A窗体内的控件是private访问级别，这时候就可以把这个控件（或者控件的值）作为窗体A的DataContext（这个属性是public访问级别）从而暴露数据
6.3.7 使用集合对象作为列表控件的ItemsSource	♣  DisplayMenberPath 指定路径

♣  SelectTemplate内部与创建Binding相关的几行代码：
FrameworkElementFactory text = ContentPresenter.CreateTextBlockFactory();
Binding binding = new Binding();
binding.Path = new PropertyPath(_dispalyMenberPath);
binding.StringFormat = _stringFormat;
text.SetBinding(TextBlock.TextProperty, binding);


♣  在使用集合类型作为列表控件的ItemSource时一般会考虑使用ObservableCollection<T>代替List<T>，因为ObservableCollection<T>类实现了InotifyCollectionChanged和InotifyPropertyChanged接口，能把集合的变化立刻通知显示它的列表控件，改变会立刻显现出来。
3.3.8使用ADO.NET对象作为Binding的源	DataTable dt=this.Load();

this.listBoxStudents.DisplayMemberPath=”Name”;
this.listBoxStudents.ItemsSource=dt.DefaultView;

♣  多数情况下我们会选择ListView控件来显示一个DataTable，需要做的改动也不是很大
DataTable dt = this.Load();
this.listViewStudents.ItemsSource = dt.DefaultView;
<ListView x:Name="listViewStudents" Height="50" Margin="5">
     <ListView.View>
          <GridView>
              <GridViewColumn Header="Id" Width="30" DisplayMemberBinding="{Binding Id}"/>
              <GridViewColumn Header="Name" Width="50" DisplayMemberBinding="{Binding Name}"/>
               <GridViewColumn Header="Age" Width="50" DisplayMemberBinding="{Binding Age}"/> 
           </GridView>
      </ListView.View>
</ListView>
 
 
♣  DataTable不能直接拿来作为ItemsSource赋值。不过，根据依赖属性的相关原理，当你把DataTable对象放在一个对象的DataContext属性里，并把ItemsSource与一个既没有指定Source又没有指定Path的Binding关联起来时，Binding却能自动找到他的DefaultView并当做自己的Source来使用
DataTable dt=this.Load();

this.listViewStudents.DataContetx = dt;
this.listViewStudents.SetBinding(ListView.ItemsSourceProperty,new Binding());


6.3.9 使用XML数据作为Binding的源	迄今为止，.Net Framework提供了两套处理XML数据的类库：
♣  符合DOM（Document Object Model，文档对象模型）标准的类库：包括XmlDocument、XmlElement、XmlNode、XmlAttribute等类。这套类库的特点是中规中矩、功能强大，但也背负了太多XML的传统和复杂。
♣  以LINQ（Language-Integrated Query，语言集成查询）为基础的类库：包括XDocument、XElement、XNode、Xattribute等类。这套类库的特点是可以使用LINQ进行操作和查询，方便快捷。

需要注意的是，当使用XML数据作为Binding的Source时我们将使用Xpath属性来指定数据的来源
使用@符号加字符串表示的是XML元素的Attribute
DisplayMemberBinding=”{Binding Xpath=@Id}”;
不加@符号的字符串表示的是子级元素
DisplayMemberBinding=”{Binding Xpath=Name}”;
详见MSDN
6.3.10使用LINQ检索结果作为Binding的源	LINQ查询的结果是一个IEnumerable<T>类型对象，而IEnumerable<T>又派生自IEnumerable，所以它可以作为列表控件的ItemsSource来使用。
6.3.11使用ObjectDataProvider对象作为Binding的Source	把对象作为数据源提供给Binding
 
#region 使用ObjectDataProvider对象作为Binding的Source
        class Calculator
        {
            //加法
            public String Add(String arg1, String arg2)
            {
                Double x = 0;
                Double y = 0;
                Double z = 0;
                if (Double.TryParse(arg1, out x) && Double.TryParse(arg2, out y))
                {
                    z = x + y;
                    return z.ToString();
                }
                return "Input Error";
            }
        }
        private void btnObj_Click(object sender, RoutedEventArgs e)
        {
            ObjectDataProvider odp = new ObjectDataProvider();
            odp.ObjectInstance = new Calculator();
            odp.MethodName = "Add";
            odp.MethodParameters.Add("100");
            odp.MethodParameters.Add("200");
            MessageBox.Show(odp.Data.ToString());
        }
        private void SetBinding()
        {
            //创建并配置ObjectDataProvider对象
            ObjectDataProvider odp = new ObjectDataProvider();
            #region 创建被包装对象之第一招
            odp.ObjectInstance = new Calculator();
            odp.MethodName = "Add";
            odp.MethodParameters.Add("0");
            odp.MethodParameters.Add("0"); 
            #endregion

            #region 创建被包装对象之第二招
            //告诉ObjectDataProvider对象将被包装对象的类型和希望调用的构造器，让ObjectDataProvider/自己去创建被包装的对象
            //odp.ObjectType = typeof(Calculator);
            //odp.ConstructorParameters.Add(arg1);
            //odp.ConstructorParameters.Add(arg2); 
            #endregion

            #region 以ObjectDataProvider对象对象为Source创建Binding
            //1、第一个Binding它的Source是ObjectDataProvider对象、Path是ObjectDataProvider对象
            //   MethodParameters属性说引用的集合中的第一个元素
            //2、BindsDirectlyToSource = true这句话的意思是告诉Binding对象只负责把从UI元素收集到
            //   的数据写入其直接Source（即ObjectDataProvider对象）而不是被ObjectDataProvider包
            //   装着的Calculator对象。
            //3、同时UpdateSourceTrigger属性被设置为一有更新立即将值传回Source。
            Binding bindingToArg1 = new Binding("MethodParameters[0]")
                {
                    Source = odp,
                    BindsDirectlyToSource = true,
                    UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged

                };
            Binding bindingToArg2 = new Binding("MethodParameters[1]")
            {
                Source = odp,
                BindsDirectlyToSource = true,
                UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged

            };

            //使用ObjectDataProvider对象为数据源，所以Path用.表示
            Binding bindingToResult = new Binding(".") { Source = odp };
            
            #endregion
            //将Binding关联到UI元素上
            //前两个TextBox的数据流向上做了限制，原因:
            //       ObjectDataProvider的MethodParameters不是依赖属性，不能作为Binding的目标
            //       数据驱动的UI的理念要求尽可能地使用数据对象作为Binding的Source而把UI元素当做Binding的Target。
            this.textBox12.SetBinding(TextBox.TextProperty, bindingToArg1);
            this.textBox13.SetBinding(TextBox.TextProperty, bindingToArg2);
            this.textBox14.SetBinding(TextBox.TextProperty, bindingToResult);
        }
        #endregion


6.3.12使用Binding的RelativeSource	♣  当一个Binding有明确的数据来源时我们可以通过Source或ElementName赋值的办法让Binding与之关联。有些时候我们不能确定作为Source的对象叫什么名字，但是知道它与作为Binding目标的对象在UI布局上有相对关系，比如控件自己关联自己的某个数据、关联自己某级容器的数据。这个时候我们就要使用Binding的RelativeSource属性。
<Grid  x:Name="g1" Background="Red" Margin="10">
   <DockPanel x:Name="d1" Background="Orange" Margin="10">
        <Grid x:Name="g2" Background="Yellow" Margin="10">
            <DockPanel x:Name="d2" Background="LawnGreen" Margin="10">
                <TextBox x:Name="textBox15" Margin="10" FontSize="24"
                     Text="{Binding RelativeSource={RelativeSource Mode=FindAncestor,AncestorLevel=1,
                           AncestorType={x:Type Grid}},Path=Name}"></TextBox>
            </DockPanel>
       </Grid>
   </DockPanel>
</Grid>

相等的C#代码：
#region 6.3.12使用Binding的RelativeSource
        /// <summary>
        /// 
        /// </summary>
        private void UserRelativeSourceToBinding()
        {
            //引用数据绑定元素父链中的上级
            RelativeSource rs = new RelativeSource(RelativeSourceMode.FindAncestor);
            //指的是以Binding目标控件为起点的层级偏移量——d2偏移量是1、g2偏移量是2，以此类推。
            rs.AncestorLevel = 1;
            //该属性告诉Binding寻找哪个类型的对象作为自己的源，不是这个类型的对象会被跳过
            rs.AncestorType = typeof(Grid);
            //对象的某个属性，作为数据源
            Binding binding = new Binding("Name");
            this.textBox15.SetBinding(TextBox.TextProperty, binding);

            //关联自身属性
            //RelativeSource rrs = new RelativeSource();
            //rrs.Mode = RelativeSourceMode.Self;
            //Binding bbinding = new Binding("Name") { RelativeSource = rrs };
            //this.textBox15.SetBinding(TextBox.TextProperty, bbinding);

        }
        #endregion

 
public static RelativeSource PreviousData
        {
            get
            {
                if (s_previousData == null)
                {
                    s_previousData = new RelativeSource(RelativeSourceMode.PreviousData);
                }
                return s_previousData;
            }
        }

        public static RelativeSource TemplateParent
        {
            get
            {
                if (s_templateParent == null)
                {
                    s_templateParent = new RelativeSource(RelativeSourceMode.PreviousData);
                }
                return s_templateParent;
            }
        }

        public static RelativeSource Self
        {
            get
            {
                if (s_self == null)
                {
                    s_self = new RelativeSource(RelativeSourceMode.Self);
                }
                return s_self;
            }
        }



	
Binding对数据的检验和校对
	Binding的ValidationRules属性类型是Collection<ValidationRule>，从它的名称和数据类型可以得知可以为每个Binding设置多个数据校验条件，每个条件是一个ValidationRule类型对象。ValidationRule类是个抽象类，在使用时我们需要创建它的派生类并实现Validate方法。该方法的返回值是ValidationResult类型对象，如果校验通过，就把ValidationResult对象的IsValid属性设置为true，反之，需要把IsValid属性设置为false，并为其ErrorContent属性设置一个合适的消息内容（一般是个字符串）。
	详细请看实例

	Binding的数据转换
		在强类型的语言环境中，	l类型转换是非常正常的现象。
		Binding还有另外一种机制称为数据转换（Data Convert），当Source端Path所关联的数据与Target端目标属性数据类型不一致，我们可以添加数据转换器（Data Convert）。例如将字符串绑定到CheckBox上，将男、女绑定到Image上以显示不同性别。（OneWay）
		遇到这种情况，我们需要自己动手写Converter，方法是创建一个类并让这个类实现 IValueConverter接口。
// 摘要:
    //     提供一种将自定义逻辑应用于绑定的方式。
    public interface IValueConverter
    {
        // 参数:
        //   value:
        //     绑定源生成的值。
        //   targetType:
        //     绑定目标属性的类型。
        //   parameter:
        //     要使用的转换器参数。
        //   culture:
        //     要用在转换器中的区域性。
        // 返回结果:
        //     转换后的值。如果该方法返回 null，则使用有效的 null 值。
        //从Source到Target
        object Convert(object value, Type targetType, object parameter, CultureInfo culture); 
        // 参数:
        //   value:
        //     绑定目标生成的值。
        //   targetType:
        //     要转换到的类型。
        //   parameter:
        //     要使用的转换器参数。
        //   culture:
        //     要用在转换器中的区域性。
        // 返回结果:
        //     转换后的值。如果该方法返回 null，则使用有效的 null 值。
        //从Target到Source
        object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
    }

	

Binding对象的Mode属性会影响到这两个方法的调用：
TwoWay/Default→TwoWay    两个方法都有可能被调用
OneWay/Default→OneWay     只有Converter方法会被调用


	MultiBinding（多路Binding）
		有时候UI需要显示的信息不止一个数据来源决定，这时候需要使用MultiBinding，即多路Binding。
	   MultiBinding与Binding一样均以BindingBase为基类，也就是说，方式能使用Binding对象的场合都能使用MultiBinding。MultiBinding具有一个名为Bindings的属性，其类型是Collection<BindingBase>，通过这个属性MultiBinding把一组Binding对象聚合起来，处在这个集合中的Binding对象可以拥有自己的数据校验与转换机制。它们汇集起来的数据将共同决定传往MultiBinding目标的数据。
	 
	
private void SetMultiBinding()
        {
            //准备基础Binding
            Binding b1 = new Binding("Text") { Source = this.textBName };
            Binding b2 = new Binding("Text") { Source = this.textBName1 };
            Binding b3 = new Binding("Text") { Source = this.textBEmail };
            Binding b4 = new Binding("Text") { Source = this.textBEmail1 };


            //准备MultiBinding
            MultiBinding mb = new MultiBinding() { Mode = BindingMode.OneWay };
            mb.Bindings.Add(b1);
            mb.Bindings.Add(b2);
            mb.Bindings.Add(b3);
            mb.Bindings.Add(b4);
            mb.Converter = new LogonMultiBindingConverter();

            //将Button 与 MultiBinding对象关联
            this.btnSubmit.SetBinding(Button.IsEnabledProperty,mb);
        }

        public class LogonMultiBindingConverter:IMultiValueConverter
        {
            public Object Convert(Object[] values, Type targetType, Object parameter, CultureInfo culture)
            {
                if(values.Cast<String>().Any(text=>!String.IsNullOrEmpty(text))
                    &&values[0].ToString()==values[1].ToString()
                    && values[2].ToString() == values[3].ToString())
                {
                    return true;
                }
                return false;
            }
            /// <summary>
            /// 不会被调用
            /// </summary>
            /// <param name="values"></param>
            /// <param name="targetType"></param>
            /// <param name="parameter"></param>
            /// <param name="culture"></param>
            /// <returns></returns>
            public Object[] ConvertBack(Object value, Type[] targetTypes, Object parameter, CultureInfo culture)
            {
                throw new NotImplementedException();
            }
            
        }

WPF的核心理念是变传统的UI驱动程序为数据驱动UI，支撑这个理念的基础就是本章讲的Data Binding和与之相关的数据校验与转换。在使用Binding时最重要的事情就是准确地设置它的源和路径。






第七章 深入浅出话属性
7.1 属性（Property）的来龙去脉
	程序的本质就是“数据+算法”。
	类的作用只是把散落在程序中的变量和函数进行归档封装并控制对他们的访问而已。被封装在类里的变量称为字段（Field），它表示的是类或实例的状态。被封装在类里的函数称为方法（Method），它表示类或实例的功能（即能做什么）。字段和方法构成了原始的面向对象封装。
	C#规定：对类有意义的字段和方法使用Static关键字修饰、称为静态成员，通过类名加访问操作符（.）可以访问他们。
		    对类的实例方法有意义的字段和方法不加Static关键字，称为非静态成员或实例成员。
 
 
 
private int _age;
     public int Age
     {
         get { return _age; }
         set { _age = value; }}
 
 
静态字段在内存中只有一个拷贝，非静态字段则是每个实例拥有一个拷贝，无论方法是否为静态的，在内存中只会有一份拷贝，区别只是你能通过类名来访问存放指令的内存还是通过实例名来访问存放指令的内存。

 	CLR属性与依赖属：我们即可以说CLR属性是private字段的安全访问包装，也可以说private字段在后台支持（back）一个CLR属性。

7.2 依赖属性（Dependency Property）
	依赖属性就是一种可以自己没有值，并能通过使用Binding从数据源获得值（依赖在别人身上）的属性。拥有依赖属性的对象称为“依赖对象”。
	较之CLR属性的优点：节省实例对内存的开销
		                属性值可以通过Binding依赖在其他对象上。




用得着就带，用不着就不带，有必要的时候可以借别人的用一下
 

在WPF中，依赖对象的概念被DependencyObject类所实现，依赖属性的概念则由DependencyProperty类所实现。
public class DependencyObject : DispatcherObject
{
        public Object GetValue(DependencyProperty dp)
        {
                //...
        }
        public void SetValue(DependencyProperty dp, Object value)
        {
                //...
        }
}

 
从上图可以看出WPF所有UI控件都是依赖属性。WPF的类库在设计时充分利用了依赖属性的优势，UI控件的绝大对数属性都已经依赖化了。
private void Button_Click(object sender, RoutedEventArgs e)
        {
            Apple apple = new Apple();

            //无CLR包装器
            //apple.SetValue(Apple.NameProperty, this.textBox1.Text);
            //textBox2.Text = (String)apple.GetValue(Apple.NameProperty);

            //有CLR包装器
            apple.Name = this.textBox1.Text;
            this.textBox2.Text = apple.Name;

            //Apple扩展的SetBinding方法（下面两段代码不应该放在此处）
            apple.SetBinding(Apple.NameProperty, new Binding("Text") { Source = this.textBox1 });
            this.textBox2.SetBinding(TextBox.TextProperty, new Binding("Name") { Source = apple });

        }



/// <summary>
    /// 
    /// 
    /// 依赖属性默认带有类似接口INotifyPropertyChanged的功能
    /// </summary>
public class Apple:DependencyObject
{
     //CLR属性包装器
        public String Name
        {
            get { return (String)GetValue(NameProperty); }
            set { SetValue(NameProperty, value); }
        }
        /// <summary>
        /// 依赖属性
        /// //public static DependencyProperty Register(string name, Type propertyType, Type ownerType);
        /// 摘要:
        ///     使用指定的属性名称、属性类型和所有者类型注册依赖项属性。
        ///
        /// 参数:
        ///   name:
        ///     要注册的依赖项对象的名称。在所有者类型的注册命名空间内，名称必须是唯一的。
        ///
        ///   propertyType:
        ///     属性的类型。
        ///
        ///   ownerType:
        ///     正注册依赖项对象的所有者类型。
        ///
        /// 返回结果:
        ///     一个依赖项对象标识符，应使用它在您的类中设置 public static readonly 字段的值。然后，在以后使用该标识符引用依赖项对象，用于某些操作，例如以编程方式设置其值，或者获取元数据。
        /// </summary>
        public static readonly DependencyProperty NameProperty=
            DependencyProperty.Register("Name",typeof(String),typeof(Apple));
    }




 
	SetBinding方法是FrameworkElement类的方法。FrameworkElement是个相当高层的类，甚至比UIElement类的级别还高——这从侧面向我们传递了这样一个思想——微软希望能够SetBinding（即作为数据目标）的对象是UI元素。
快捷方式  propdp  tab键

7.2.3 依赖属性值存储的秘密（难点）



7.3	附加属性
附加属性的本质就是依赖属性，二者尽在注册和包装器上有一点区别。
简单示例：【20岁的男生】放在【学校】，他可能会被附加上【学号】、【班级】等属性，放在家庭，他可能会有【哥哥】、【弟弟】等属性，放在社会，他可能会有【社保】、【知己】、【球员】等属性。所以，我们不可能把所有属性在初始化的时候都进行注册。当初始化时，需要看场景从而附加给其某些特定的属性。

/// <summary>
    /// 附加属性（注意与依赖属性的区别）
    /// </summary>
    public class MiddleSchool:DependencyObject
    {
        public static int GetGrand(DependencyObject obj)
        {
            return (int)obj.GetValue(GrandProperty);
        }

        public static void SetGrand(DependencyObject obj, int value)
        {
            obj.SetValue(GrandProperty, value);
        }

        // Using a DependencyProperty as the backing store for Grand.  This enables animation, styling, binding, etc...
        /// <summary>
        /// 附加属性（在依赖属性中使用的是Register方法）
        /// </summary>
        public static readonly DependencyProperty GrandProperty =
            DependencyProperty.RegisterAttached("Grand", typeof(int), typeof(MiddleSchool), new UIPropertyMetadata(0));

    }

 




























第八章	深入浅出话事件
就像属性系统在WPF中得到升级、进化为依赖属性一样，事件系统在WPF中也被升级——进化成为路由事件（Routed Event），并在其基础上衍生出命令传递机制。这些机制在很大程度上减少了对程序员的束缚，让程序设计和实现更加灵活，模块之间的耦合度页进一步降低。


8.1 近观WPF的属性结构
	路由（Routed）事件的大意是这样：起点与终点间有若干个中转站，从起点出发后经过每个中转站时要作出选择，最终以正确（比如最快或最短）的路径到达终点。编程的本质是用编译器（有时要借助类库）来扩展操作系统的功能，所以程序的基本运行不可能脱离操作系统——windows本身就是一种消息驱动的操作系统，所以我们的程序注定都是消息驱动的，程序运行时也要把自己的消息系统与整个操作系统的消息系统“联通”才能够被执行和响应。
直接消息模型→可传递的消息模型


	WPF事件的路由环境是UI组件树
		逻辑树（Logical Tree）：它完全由布局组件和控件构成（包括列表类控件中的条目元素），即它的每个节点不是布局组
							件就是控件。
		可视元素树（Visual Tree）：有自己的基部并向上生长出多级分叉。


8.2	事件的来龙去脉
事件的前身是消息（Message）。Windows是消息驱动的操作系统，运行其上的程序也遵照这个机制运行。消息的本质就是一
条数据，这条数据里记载着消息的类别，必要的时候还记载一些消息参数。
 
 
 
直接事件模型
 




CLR直接事件模型中，事件的拥有者就是消息的发送者（Sender）
 
 


8.3	深入浅出路由事件
 
<Grid x:Name="gridRoot" Background="Linen">
        <Grid x:Name="gridA" Margin="10" Background="Blue">
            <Grid.ColumnDefinitions>
                <ColumnDefinition/>
                <ColumnDefinition/>
            </Grid.ColumnDefinitions>
            <Canvas x:Name="canvasLeft" Grid.Column="0" Background="Red" Margin="10">
                <Button x:Name="buttonLeft" Content="Left" Width="40" Height="100" Margin="10"/>
            </Canvas>
            <Canvas x:Name="canvasRight" Grid.Column="1" Background="Yellow" Margin="10">
                <Button x:Name="buttonRight" Content="Right" Width="40" Height="100" Margin="10"/>
            </Canvas>
        </Grid>
    </Grid>

 
创建自定义路由事件
（1）	声明并注册路由事件
（2）	为路由事件添加CLR事件包装
（3）	创建可以激发路由事件的方法
public abstract class ButtonBase : ContentControl, ICommandSource
    {
        //声明并注册路由事件
        public static readonly RoutedEvent ClickEvent=/*注册路由事件*/;

        //为路由事件加CLR事件包装器
        public event RoutedEventHandler Click
        {
            add { this.AddHandler(ClickEvent, value); }
            remove { this.RemoveHandler(ClickEvent, value); }
        }

        //激发路由事件的方法，此方法在用法单击鼠标时会被Windows系统调用
        protected virtual void OnClick()
        {
            RoutedEventArgs newEvent = new RoutedEventArgs(Button.ClickEvent,this);
            this.RaiseEvent(newEvent);
        }
    }

RoutedEventArgs事件消息类
snippet快捷键，与依赖属性相似
仍然可以使用  ＋＝   －＝
 
//声明并注册路由事件
        public static readonly RoutedEvent ClickEvent=EventManager.RegisterRoutedEvent
            ("Click",RoutingStrategy.Bubble,typeof(RoutedEventHandler),typeof(ButtonBase));
 
/// <summary>
    /// 用于承载时间消息的事件参数
    /// </summary>
    class ReportTimeEventArgs : RoutedEventArgs
    {
        public ReportTimeEventArgs(RoutedEvent routedEvent, Object source)
            :base(routedEvent,source)
        {

        }

        public DateTime ClickTime { get; set; }
    }

    class TimeButton : Button
    {
        //声明和注册路由事件
        public static readonly RoutedEvent ReportTimeEvent = EventManager.RegisterRoutedEvent
            ("ReportTime", RoutingStrategy.Bubble, typeof(EventHandler<ReportTimeEventArgs>), typeof(TimeButton));

        //CLR包装器
        public event RoutedEventHandler ReportTime
        {
            add { this.AddHandler(ReportTimeEvent, value); }
            remove { this.RemoveHandler(ReportTimeEvent,value); }
        }

        //激发路由事件
        protected override void OnClick()
        {
            base.OnClick();//保证原有功能正常使用、Click事件能被激发

            ReportTimeEventArgs args = new ReportTimeEventArgs(ReportTimeEvent, this);
            args.ClickTime = DateTime.Now;
            this.RaiseEvent(args);
        }
    }




private void ReportTimeHandler(Object sender, ReportTimeEventArgs e)
        {
            FrameworkElement element = sender as FrameworkElement;
            String timeStr = e.ClickTime.ToString();
            String content = String.Format("{0}到达{1}", timeStr, element.Name);
            this.listBox.Items.Add(content);
            if (element == this.grid_2)
            {
                e.Handled = true;
            }
        }
<!--注册并激发事件验证-->
        <Grid x:Name="grid_1" local:TimeButton.ReportTime="ReportTimeHandler" Grid.Column="1" Grid.Row="0">
            <Grid x:Name="grid_2"  local:TimeButton.ReportTime="ReportTimeHandler">
                <Grid x:Name="grid_3"  local:TimeButton.ReportTime="ReportTimeHandler">
                    <StackPanel x:Name="stackPanel_1" local:TimeButton.ReportTime="ReportTimeHandler">
                        <ListBox x:Name="listBox"></ListBox>
                        <local:TimeButton x:Name="timeButton" Width="80" Height="80"
                                          Content="报时" local:TimeButton.ReportTime="ReportTimeHandler"/>
                    </StackPanel>
                </Grid>
            </Grid>
        </Grid>

如何让一个事件在某个节点处不再传递下去：
    路由事件携带的事件参数必须是RoutedEventArgs类或其派生类的实例，RoutedEventArgs具有一个bool类型属性Handler，一旦这个属性被设置为true，就表示路由事件“已经被处理”，那么路由事件也就不必再往下传递了。

 


8.3.3 RoutedEventArgs的Source与OriginalSource
 

8.3.4 事件也附加——深入浅出附加事件
	附加事件（Attached Event）——路由事件
		拥有附加事件的类：
			Binding类：SourceUpdated事件、TargetUpdated事件。
			Mouse类：MouseEnter事件、MouseLeave事件、MouseDowm事件、MouseUp事件等。
			Keyboard类：KeyDown事件、KeyUp事件
		拥有路由事件的类：
			Button、Slider、TextBox
			区别：路由事件的宿主都是些拥有可视化实体的界面元素，而附加事件则不具备显示在用户界面上的能力


在一个非UIElement派生类中注册路由事件，则这个类的实例既不能激发自己（Raise）此路由事件也无法自己侦听此路由事件，只能把这个事件的激发“附着”在某个具有RaiseEvent方法的对象上，借助这个对象的RaiseEvent方法把事件发送出去：事件的侦听任务也只能交给别的对象去做	。
 









第九章	深入浅出话命令（难点）
有了事件为什么还要命令？
事件的作用的发布、传播、送达，支持事件使命完成。至于接收者如何响应事件送来的消息其中并没有规定，每个接收者
可以使用自己的行为来响应事件

事件不具备约束力，而命令是具有约束力的
命令除了可以约束代码，还可以约束步骤逻辑
9.1.1 命令系统的基本元素
 
第十章	深入浅出话资源
WPF不但支持程序级的传统资源，同时还推出了独具特色的对象级资源，每个界面元素都可以携带自己的资源并可被自己的
子级元素共享。各种模板、程序样式、主题就经常放在对象级资源里。
	数据四等级：
		数据库里的数据相当于存放在仓库里
		资源文件里的数据相当于放在旅行箱里
		WPF对象资源里的数据相当于放在随身携带的背包里
		变量中的数据相当于拿在手里
	
	StaticResource
	DynamicResource

//图片资源
            Uri imgUri = new Uri(@"Resources/Images/Rafale.jpg",UriKind.Relative);
            this.imageControl.Source =new BitmapImage(imgUri);


<StackPanel Margin="5,5,5,0" Height="100">
            <Grid Margin="5">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto"></ColumnDefinition>
                    <ColumnDefinition Width="28" ></ColumnDefinition>
                    <ColumnDefinition Width="*"></ColumnDefinition>
                </Grid.ColumnDefinitions>
                <Grid.RowDefinitions>
                    <RowDefinition Height="23"></RowDefinition>
                    <RowDefinition Height="4"></RowDefinition>
                    <RowDefinition Height="23"></RowDefinition>
                    <RowDefinition Height="*"></RowDefinition>
                </Grid.RowDefinitions>
                <TextBlock Text="{x:Static prop:Resources.UserName}" Grid.Column="1" Grid.Row="0"/>
                <TextBlock x:Name="textBlockPassword" Grid.Row="2"/>
                <TextBox BorderBrush="Black" Grid.Column="2"/>
                <TextBox BorderBrush="Black" Grid.Column="2" Grid.Row="2"/>
                <Image Source="Resources/1-1.png" Grid.Row="3"></Image>
                <Image Grid.Row="3" Grid.Column="1"
                    Source="pack://application:,,,/Resources/1-1.png" ></Image>
                <Image x:Name="imageControl" Grid.Row="3" Grid.Column="2"></Image>
            </Grid>
        </StackPanel>

 





第十一章  深入浅出话模板（重点）
	ControlTemplate：是算法内容的表现形式
	DataTemplate：是数据内容的表现形式

	事件驱动是控件和控件之间沟通或者说是形式与形式之间的沟通，数据驱动则是数据与控件之间的沟通、是内容决定形式。使用DataTempalte就可以很方便地把事件驱动模式升级为数据驱动模式
 




















第十二章 动画与绘图
基本图形（都是Shape类的派生类）：
	Line：直线段
	Rectangle：矩形
	Ellipse：圆
	Polygon：多边形
	Polyline：折线（不闭合）
	Path：路径（闭合区域），基本图形中功能最强大



矩形：
	SolidColorBrush：实心画刷
	LinearGradientBrush：线性渐变画刷
	RadialGradientBrush：径向渐变画刷
	ImageBrush：使用图片作为填充内容
	DrawingBrush：使用矢量图（Vector）和位图（BitMap）作为填充内容
	VisualBrush：可视化填充
 
 


 
 




路径标记语法
 
 




WPF规定：可以用来制作动画的属性必须是依赖属性。时
 

   

 


 



 
 
<!--SplineDoubleKeyFrme关键帧-->
        <Button Content="Move1" VerticalAlignment="Top" HorizontalAlignment="Left" Width="50" Height="50"
                x:Name="btnSplineDoubleKeyFrme" Click="btnSplineDoubleKeyFrme_Click" 
                Style="{StaticResource ResourceKey=btnStyle1}" Grid.Column="1" 
                Background="LightBlue" Margin="7,6,0,0">
            <Button.RenderTransform>
                <TranslateTransform x:Name="ty" X="0" Y="0"/>
            </Button.RenderTransform>
        </Button>


private void btnSplineDoubleKeyFrme_Click(object sender, RoutedEventArgs e)
        {
            //创建动画
            DoubleAnimationUsingKeyFrames dakX = new DoubleAnimationUsingKeyFrames();
            dakX.Duration = new Duration(TimeSpan.FromMilliseconds(1000));

            //创建、添加关键帧
            SplineDoubleKeyFrame kf = new SplineDoubleKeyFrame();
            kf.KeyTime = KeyTime.FromPercent(1);
            kf.Value = 400;
            KeySpline ks = new KeySpline();
            ks.ControlPoint1 = new Point(0, 1);
            ks.ControlPoint2 = new Point(1, 0);
            kf.KeySpline = ks;
            dakX.KeyFrames.Add(kf);

            this.ty.BeginAnimation(TranslateTransform.XProperty, dakX);
        }


 
<!--路径动画movingPath-->
        <Grid Grid.Column="2" x:Name="LayoutRoot">
            <Grid.Resources>
                <PathGeometry x:Key="movingPath" Figures="M 0,150 C300,-100 300,400 600,120"/>
            </Grid.Resources>
            <Button x:Name="btnDoubleAnimationUsingPath" Content="Move" HorizontalAlignment="Left" VerticalAlignment="Top"
                    Width="80" Height="80" Click="btnDoubleAnimationUsingPath_Click" Style="{StaticResource ResourceKey=btnStyle1}" 
                    Background="LightCoral"  >
                <Button.RenderTransform>
                    <TranslateTransform x:Name="tp" X="0" Y="0"></TranslateTransform>
                </Button.RenderTransform>
            </Button>
        </Grid>



private void btnDoubleAnimationUsingPath_Click(object sender, RoutedEventArgs e)
        {
            //从XAML代码中获取移动路径数据
            PathGeometry pg = this.LayoutRoot.FindResource("movingPath") as PathGeometry;
            Duration duration=new Duration(TimeSpan.FromMilliseconds(1000));

            //创建动画
            DoubleAnimationUsingPath dapX = new DoubleAnimationUsingPath();
            dapX.PathGeometry = pg;
            //沿着X坐标
            dapX.Source = PathAnimationSource.X;
            dapX.Duration = duration;

            DoubleAnimationUsingPath dapY = new DoubleAnimationUsingPath();
            dapY.PathGeometry = pg;
            //沿着X坐标
            dapY.Source = PathAnimationSource.Y;
            dapY.Duration = duration;

            //自动返回、永远循环
            dapX.AutoReverse = true;
            dapX.RepeatBehavior = RepeatBehavior.Forever;
            dapY.AutoReverse = true;
            dapY.RepeatBehavior = RepeatBehavior.Forever;

            //执行动画
            this.tp.BeginAnimation(TranslateTransform.XProperty, dapX);
            this.tp.BeginAnimation(TranslateTransform.YProperty, dapY);
        }



 

用C#实现：
<Grid Margin="6">
        <!--布局控制-->
        <Grid.RowDefinitions>
            <RowDefinition Height="38"/>
            <RowDefinition Height="38"/>
            <RowDefinition Height="38"/>
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
            <ColumnDefinition/>
            <ColumnDefinition Width="60"/>
        </Grid.ColumnDefinitions>
        
        <!--跑到（红）-->
        <Border BorderBrush="Gray" BorderThickness="1" Grid.Row="0">
            <Ellipse x:Name="ballR" Height="36" Width="36" Fill="Red"
                     HorizontalAlignment="Left">
                <Ellipse.RenderTransform>
                    <TranslateTransform x:Name="ttR"/>
                </Ellipse.RenderTransform>
            </Ellipse>
        </Border>

        <!--跑到（绿）-->
        <Border BorderBrush="Gray" BorderThickness="1,0,1,1" Grid.Row="1">
            <Ellipse x:Name="ballG" Height="36" Width="36" Fill="LawnGreen"
                     HorizontalAlignment="Left">
                <Ellipse.RenderTransform>
                    <TranslateTransform x:Name="ttG"/>
                </Ellipse.RenderTransform>
            </Ellipse>
        </Border>

        <!--跑到（绿）-->
        <Border BorderBrush="Gray" BorderThickness="1,0,1,1" Grid.Row="2">
            <Ellipse x:Name="ballB" Height="36" Width="36" Fill="Blue"
                     HorizontalAlignment="Left">
                <Ellipse.RenderTransform>
                    <TranslateTransform x:Name="ttB"/>
                </Ellipse.RenderTransform>
            </Ellipse>
        </Border>
        <!--按钮-->
        <Button Content="Go!" Grid.Column="1" Grid.RowSpan="3" Click="Button_Click"/>
    </Grid>





private void Button_Click(object sender, RoutedEventArgs e)
        {
            Duration duration = new Duration(TimeSpan.FromMilliseconds(600));

            //红色小球匀速运动
            DoubleAnimation daRX = new DoubleAnimation();
            daRX.Duration = duration;
            daRX.To = 40;


            //绿色小球匀速运动
            DoubleAnimationUsingKeyFrames dakGX = new DoubleAnimationUsingKeyFrames();
            dakGX.Duration = duration;
            SplineDoubleKeyFrame kfG = new SplineDoubleKeyFrame(400, KeyTime.FromPercent(1.0));
            kfG.KeySpline = new KeySpline(1, 0, 0, 1);
            dakGX.KeyFrames.Add(kfG);


            //蓝色小球匀速运动
            DoubleAnimationUsingKeyFrames dakBX = new DoubleAnimationUsingKeyFrames();
            dakBX.Duration = duration;
            SplineDoubleKeyFrame kfB = new SplineDoubleKeyFrame(400, KeyTime.FromPercent(1.0));
            kfB.KeySpline = new KeySpline(0, 1, 1, 0);
            dakBX.KeyFrames.Add(kfB);


            //创建场景
            Storyboard storyboard = new Storyboard();

            Storyboard.SetTargetName(daRX, "ttR");
            Storyboard.SetTargetProperty(daRX,new PropertyPath(TranslateTransform.XProperty));

            Storyboard.SetTargetName(dakGX, "ttG");
            Storyboard.SetTargetProperty(dakGX, new PropertyPath(TranslateTransform.XProperty));

            Storyboard.SetTargetName(dakBX, "ttB");
            Storyboard.SetTargetProperty(dakBX, new PropertyPath(TranslateTransform.XProperty));

            storyboard.Duration = duration;
            storyboard.Children.Add(daRX);
            storyboard.Children.Add(dakBX);
            storyboard.Children.Add(dakGX);

            storyboard.Begin(this);
            storyboard.Completed += (a, b) => { MessageBox.Show(ttR.X.ToString()); };
        }

</h5>
	
</body>
</html>
